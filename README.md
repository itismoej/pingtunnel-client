# pingtunnel-client

Cross-platform client that can run **proxy** mode or **full-tunnel VPN** mode by combining:

- `pingtunnel` client (SOCKS5)
- `tun2socks` (TUN <-> SOCKS)
- OS-specific routing scripts

The UI is a Flutter app (simple connect toggle + config URI input). The runtime copies bundled binaries and scripts into a user-local folder and launches them as needed.

## Status

- **Desktop (Windows/macOS/Linux)**: Proxy + VPN modes wired.
- **Android**: Flutter UI can be generated, but VPN mode needs native integration (see notes below).

## Quick start

1) Prepare binaries (copy pingtunnel from your local pack and download tun2socks):

```
./scripts/prepare_binaries.sh /home/moe/Projects/pingtunnel/cmd/pack
```

If the download step fails (offline or restricted network), download the `tun2socks` release assets manually and place them under:

```
templates/assets/binaries/tun2socks/<os>-<arch>/tun2socks[.exe]
```

2) Generate the Flutter app (after installing Flutter):

```
./scripts/bootstrap_flutter.sh
```

This repo treats `templates/` as the source of truth. The Flutter app's
`app/lib/`, `app/assets/`, and Android `app/android/app/src/main/jniLibs/`
are generated by the bootstrap script and are not tracked in git.

3) Run the app:

```
cd app
flutter run -d windows   # or macos/linux/android
```

## Linux .deb packaging (no prompts)

To produce a Debian package that installs the polkit helper and policy (so VPN
does not prompt), run:

```
./scripts/build_deb.sh
```

Install:

```
sudo dpkg -i dist/pingtunnel-client_<version>_<arch>.deb
```

## Config URI

Example:

```
pingtunnel://your-server.com?key=281&lport=1080&mode=vpn&iface=eth0
```

Supported params:
- `key` (required): pingtunnel key
- `lport`: local SOCKS port (default: 1080)
- `port`: pingtunnel server port (optional; appended to host)
- `mode`: `proxy` or `vpn`
- `encrypt`: `aes128`, `aes256`, or `chacha20` (optional; when set, `key` is not required)
- `encrypt_key`: encryption key/passphrase (required if `encrypt` is set)
- `iface`: outbound interface name (optional; auto-detected if omitted)
- `tun`: TUN device name override (optional)
- `dns`: DNS override (Windows VPN script)

## VPN routing scripts

Desktop VPN mode calls scripts under `assets/scripts/` after extracting them locally:

- Linux: creates `ptun0`, configures routes, disables rp_filter, and adds a
  host route to the pingtunnel server to avoid routing loops.
- Linux DNS: forces TCP DNS (DoT via systemd-resolved when available, otherwise
  rewrites `/etc/resolv.conf` with `options use-vc`). This avoids UDP DNS which
  pingtunnel's SOCKS5 core cannot carry.
- macOS: uses `utun2` + split /1 routes.
- Windows: expects `wintun` adapter and adds default route.

**Important**: VPN mode requires admin/root privileges to add routes and create TUN devices.

### Linux polkit helper (optional)

VPN on Linux needs privileged routing. To avoid prompts during normal use,
install a small polkit helper once:

```
sudo ./scripts/install_polkit_helper.sh
```

To remove it:

```
sudo ./scripts/uninstall_polkit_helper.sh
```

## Windows notes

- `tun2socks` expects the Wintun driver. If not present, install Wintun and ensure `wintun.dll` is on PATH or alongside the tun2socks binary.

## Android notes

Android support is wired via a native `VpnService` + foreground services. You **must** provide Android binaries for:

- `pingtunnel` (GOOS=android, GOARCH=arm64/arm)
- `tun2socks` (GOOS=android, GOARCH=arm64/arm)

Place them under:

```
templates/assets/binaries/pingtunnel/android-arm64/pingtunnel
templates/assets/binaries/pingtunnel/android-arm/pingtunnel
templates/assets/binaries/tun2socks/android-arm64/tun2socks
templates/assets/binaries/tun2socks/android-arm/tun2socks
```

The VPN flow is:

- `VpnService` establishes the TUN interface
- `pingtunnel` provides local SOCKS5
- `tun2socks` runs with `-device fd://<fd>` and `-proxy socks5://127.0.0.1:<port>`

Example build commands (if you have Go installed):

```
# pingtunnel
cd ~/Projects/pingtunnel
GOOS=android GOARCH=arm64 CGO_ENABLED=0 go build -o \
  /home/moe/Projects/pingtunnel-client/templates/assets/binaries/pingtunnel/android-arm64/pingtunnel \
  ./cmd

# tun2socks
cd ~/Projects/tun2socks
GOOS=android GOARCH=arm64 CGO_ENABLED=0 go build -o \
  /home/moe/Projects/pingtunnel-client/templates/assets/binaries/tun2socks/android-arm64/tun2socks \
  ./cmd/tun2socks
```

Or use the helper script:

```
./scripts/build_tun2socks_android.sh ~/Projects/tun2socks
```

By default the script builds **arm64 only**. To build 32-bit arm you need the Android NDK and cgo enabled:

```
export ANDROID_NDK_HOME=~/Android/Sdk/ndk/<version>
BUILD_ARM32=1 ./scripts/build_tun2socks_android.sh ~/Projects/tun2socks
```

If your environment needs a proxy for Go module downloads, export `HTTP_PROXY` / `HTTPS_PROXY` (or `ALL_PROXY`) before running the build.

### Android ICMP limitation (rootless)

`pingtunnel` opens a raw ICMP socket (`ip4:icmp`). On Android, raw ICMP is **not allowed** for normal apps, so the client will fail with:

```
listen ip4:icmp 0.0.0.0: socket: operation not permitted
```

If you want to try a **rootless** workaround, apply the patch that switches Android to the unprivileged ICMP **ping socket** (`SOCK_DGRAM, IPPROTO_ICMP`) first:

```
./scripts/apply_pingtunnel_android_patch.sh ~/Projects/pingtunnel
```

Then rebuild your Android binaries and re-run `./scripts/prepare_binaries.sh`.

Note: Some Android kernels still block unprivileged ICMP, so this may still fail. If it does, pingtunnel cannot run on Android without root or a different transport core.

## Files

- `scripts/prepare_binaries.sh`: copies pingtunnel + downloads tun2socks
- `scripts/bootstrap_flutter.sh`: creates Flutter app and copies templates
- `templates/lib/`: Flutter UI and controller code
- `templates/assets/`: binaries + scripts packaged as Flutter assets
